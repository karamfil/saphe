<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>bundleid</key>
	<string>kmarchand.calendar-avail</string>
	<key>connections</key>
	<dict>
		<key>0896B426-0376-4FDA-B15E-12BA2F091969</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>B0E2DAEB-48D4-43F5-B2DB-2C9CE2F8B3EE</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>15299C7A-CDEA-4359-8898-446F2892DB7C</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>FF316160-82F1-4AC1-8D82-72A1F0AC9ED6</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>B0E2DAEB-48D4-43F5-B2DB-2C9CE2F8B3EE</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>FFCD5930-BD14-4FEC-A342-F99A6A8C5A56</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>FF316160-82F1-4AC1-8D82-72A1F0AC9ED6</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>A70A4E1E-712E-4575-967A-0AA64960904D</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
	</dict>
	<key>createdby</key>
	<string>Kevin Marchand</string>
	<key>description</key>
	<string>Read Mac Calendar DB and copy to clipboard</string>
	<key>disabled</key>
	<false/>
	<key>name</key>
	<string>Calendar Availability or Schedule to Clipboard</string>
	<key>objects</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>argumenttype</key>
				<integer>2</integer>
				<key>keyword</key>
				<string>availability</string>
				<key>subtext</key>
				<string></string>
				<key>text</key>
				<string>Copy calendar availability to clipboard</string>
				<key>withspace</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.keyword</string>
			<key>uid</key>
			<string>15299C7A-CDEA-4359-8898-446F2892DB7C</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>concurrently</key>
				<false/>
				<key>escaping</key>
				<integer>68</integer>
				<key>script</key>
				<string>#!/usr/bin/python
#
# Script to copy Mac Calendar DB data to clipboard
#   as either schedule data, or busy/avail
# Kevin Marchand - 2016
#

import sqlite3
import datetime
import calendar
import pytz
import getpass
from time import sleep
import subprocess

# copy to clipboard for mac (ref: http://stackoverflow.com/a/25802742)

def write_to_clipboard(output):
    process = subprocess.Popen(
        'pbcopy', env={'LANG': 'en_US.UTF-8'}, stdin=subprocess.PIPE)
    process.communicate(output.encode('utf-8'))

# Setup


local_user = getpass.getuser()

# default timezone
default_timezone = 'America/Toronto'

# days after current date to include
lookahead_day_count = 7

# hour of start of work days (24h clock, in local time)
work_start_hour = 9

# hour of start of work days (24h clock, in local time)
work_end_hour = 17

# Whether or not to include Saturday and Sunday
skip_weekends = True

# show all calendars or only specified ones (see next setting)
show_all_cal = True

# string of calendar IDs in parens (only applies if show_all_cal is False)
# calendar IDs can be identified by running "calendar-avail-listcals.py"
cal_list = '(60)'



# Offset the start and end times for the db query from the calendar epoch and convert to seconds

epoch_anchor_utc = datetime.datetime.strptime("01-01-2001", "%m-%d-%Y")
query_start_utc = datetime.datetime.utcnow()
query_end_utc = query_start_utc + datetime.timedelta(
    seconds=lookahead_day_count * 24 * 60 * 60)

query_start_seconds = abs((query_start_utc - epoch_anchor_utc).days) * 24 * 60 * 60
query_end_seconds = abs((query_end_utc - epoch_anchor_utc).days) * 24 * 60 * 60

# Connect to Calendar sqlite DB and query events

conn = sqlite3.connect("/Users/%s/Library/Calendars/Calendar Cache" % local_user)
cursor = conn.cursor()

if show_all_cal is True:
    cursor.execute('''select
    	ZSTARTDATE,
    	ZENDDATE,
    	ZTIMEZONE,
    	ZTITLE
        from ZCALENDARITEM
        where ZSTARTDATE &gt; %s
        and ZENDDATE &lt; %s''' % (query_start_seconds, query_end_seconds))
else:
    cursor.execute('''select
    	ZSTARTDATE,
    	ZENDDATE,
    	ZTIMEZONE,
    	ZTITLE
        from ZCALENDARITEM
        where ZSTARTDATE &gt; %s
        and ZENDDATE &lt; %s
        and ZCALENDAR in %s''' % (query_start_seconds, query_end_seconds, cal_list))

calendar_entries = cursor.fetchall()

conn.close()

# convert times from db into datetime objects and sort by start times

calendar_entries_processed = []

for entry in calendar_entries:

    zstartdate = entry[0]
    zenddate = entry[1]
    entry_tz = entry[2]
    title = entry[3]

    try:
        local_tz = pytz.timezone (entry_tz)
    except:
        local_tz = pytz.timezone (default_timezone)

    utc_start = epoch_anchor_utc + datetime.timedelta(seconds=zstartdate)
    utc_start = utc_start.replace(second=0, microsecond=0).replace(tzinfo=pytz.utc)
    utc_end = epoch_anchor_utc + datetime.timedelta(seconds=zenddate)
    utc_end = utc_end.replace(second=0, microsecond=0).replace(tzinfo=pytz.utc)

    calendar_entries_processed.append((utc_start, utc_end, title, entry_tz))

calendar_entries_sorted = sorted(calendar_entries_processed, key=lambda x: x[0])

# Remove all-day events (anything over 23 hours)

for entry in calendar_entries_sorted:
    event_start = entry[0]
    event_end = entry[1]
    if event_end - event_start &gt; datetime.timedelta(hours=23):
        calendar_entries_sorted.remove(entry)

# Build list of the days within the lookahead period, set initial date to today

lookahead_days = []
lookahead_date_utc = datetime.datetime.today().replace(
    hour=0, minute=0, second=0, microsecond=0).replace(tzinfo=pytz.utc)

for x in range(0,lookahead_day_count + 1):
    lookahead_days.append(lookahead_date_utc)
    lookahead_date_utc = lookahead_date_utc + datetime.timedelta(days=1)

# For every date in the lookahead, store all events in the sched_text string

sched_text = ''

for d in lookahead_days:

    wd = calendar.day_name[d.weekday()]
    if skip_weekends == True and (wd == 'Saturday' or wd == 'Sunday'):
            continue

    sched_text += '\n'
    sched_text += wd + ' - ' + str(d)[:10] + '\n\n'
    entry_count = 0
    for entry in calendar_entries_sorted:
        if entry[0] &gt; d and entry[1] &lt; d + datetime.timedelta(days=1):
            entry_count += 1
            start_local = entry[0].astimezone(pytz.timezone (entry[3]))
            end_local = entry[1].astimezone(pytz.timezone (entry[3]))
            sched_text += str(start_local)[11:16] + ' - ' + \
                str(end_local)[11:16] + ' - ' + entry[2] + '\n'
    if entry_count == 0:
        sched_text += '(No Events)' + '\n'

#  Work out busy/free times and store summary in the basummary_text string

basummary_text = ''

for d in lookahead_days:

    busy_minutes = set()
    day_minutes = set()
    busy_avail = []
    utc = pytz.timezone('UTC')

    wd = calendar.day_name[d.weekday()]

    if skip_weekends == True and (wd == 'Saturday' or wd == 'Sunday'):
            continue

    # Check if each entry in the overall list of events occured on this date

    for entry in calendar_entries_sorted:

        entry_start = entry[0]
        entry_end = entry[1]

        if entry_start &gt; d and entry_end &lt; d + datetime.timedelta(days=1):

            # Found an event that occurs today

            entry_num_minutes = abs((entry_end - entry_start).seconds) / 60

            # add start minute for the event to the busy_minutes set
            busy_minutes.add(entry_start)

            # add all other minutes that fall within event to the busy_minutes set
            for x in range(1, entry_num_minutes):
                busy_minutes.add(entry_start + datetime.timedelta(minutes=x))

    day_start_local = d.astimezone(pytz.timezone (default_timezone)).replace(
        hour=work_start_hour, minute=0, second=0, microsecond=0)

    if d.day != day_start_local.day:
        day_start_local = day_start_local + datetime.timedelta(days=1)

    day_end_local = d.astimezone(pytz.timezone (default_timezone)).replace(
        hour=work_end_hour, minute=0, second=0, microsecond=0)

    if d.day != day_end_local.day:
        day_end_local = day_end_local + datetime.timedelta(days=1)

    day_start = day_start_local.astimezone(utc)
    day_end = day_end_local.astimezone(utc)

    day_num_minutes = abs((day_end - day_start).seconds) / 60

    day_minutes.add(day_start)

    for x in range (1, day_num_minutes):
        m = day_start + datetime.timedelta(minutes=x)
        m_utc = m.astimezone(utc)
        day_minutes.add(m_utc)

    busy_minutes_filtered = set()

    for m in busy_minutes:
        if m &lt; day_end and m &gt; day_start:
            busy_minutes_filtered.add(m)

    avail_minutes = day_minutes.symmetric_difference(busy_minutes_filtered)

    for x in avail_minutes:
        busy_avail.append((x, 'Available'))

    for x in busy_minutes_filtered:
        busy_avail.append((x, 'Busy'))

    busy_avail_sorted = sorted(busy_avail, key=lambda x: x[0])

    # Busy/Avail summary

    basummary_text += '\n'
    basummary_text += wd + ' - ' + str(d)[:10] + '\n\n'

    first_minute = busy_avail_sorted[0][0]
    first_status = busy_avail_sorted[0][1]

    start_of_streak_time = first_minute
    temp_end_time = first_minute + datetime.timedelta(seconds=60)
    temp_last_status = first_status


    for entry in busy_avail_sorted[1:]:
        entry_time = entry[0]
        entry_status = entry[1]

        if entry != busy_avail_sorted[-1]:

            if entry_status == temp_last_status:
                # streak ongoing
                temp_end_time = entry_time + datetime.timedelta(seconds=60)
            else:
                # streak broken
                basummary_text += str(start_of_streak_time.astimezone(
                    pytz.timezone (default_timezone)))[11:16] + ' to ' + str(
                        temp_end_time.astimezone(pytz.timezone (
                                default_timezone)))[11:16] + ' - ' + temp_last_status
                basummary_text += '\n'
                temp_last_status = entry_status
                start_of_streak_time = entry_time

        # last item in list
        else:
            temp_end_time = temp_end_time + datetime.timedelta(seconds=60)
            basummary_text += str(
                start_of_streak_time.astimezone(pytz.timezone (
                    default_timezone)))[11:16] + ' to ' + str(
                        temp_end_time.astimezone(pytz.timezone (
                            default_timezone)))[11:16] + ' - ' + temp_last_status
            basummary_text += '\n'

# comment out one of the two lines below depending on whether the schedule
# summary or busy/available summary shoudl be copied to the clipboard

write_to_clipboard(basummary_text)
# write_to_clipboard(sched_text)
</string>
				<key>scriptargtype</key>
				<integer>0</integer>
				<key>scriptfile</key>
				<string></string>
				<key>type</key>
				<integer>3</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>FF316160-82F1-4AC1-8D82-72A1F0AC9ED6</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>lastpathcomponent</key>
				<false/>
				<key>onlyshowifquerypopulated</key>
				<false/>
				<key>removeextension</key>
				<false/>
				<key>text</key>
				<string></string>
				<key>title</key>
				<string>Calendar availability copied to clipboard</string>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.notification</string>
			<key>uid</key>
			<string>A70A4E1E-712E-4575-967A-0AA64960904D</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argumenttype</key>
				<integer>2</integer>
				<key>keyword</key>
				<string>schedule</string>
				<key>subtext</key>
				<string></string>
				<key>text</key>
				<string>Copy schedule to clipboard</string>
				<key>withspace</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.keyword</string>
			<key>uid</key>
			<string>0896B426-0376-4FDA-B15E-12BA2F091969</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>concurrently</key>
				<false/>
				<key>escaping</key>
				<integer>102</integer>
				<key>script</key>
				<string>#!/usr/bin/python
#
# Script to copy Mac Calendar DB data to clipboard
#   as either schedule data, or busy/avail
# Kevin Marchand - 2016
#

import sqlite3
import datetime
import calendar
import pytz
import getpass
from time import sleep
import subprocess

# copy to clipboard for mac (ref: http://stackoverflow.com/a/25802742)

def write_to_clipboard(output):
    process = subprocess.Popen(
        'pbcopy', env={'LANG': 'en_US.UTF-8'}, stdin=subprocess.PIPE)
    process.communicate(output.encode('utf-8'))

# Setup


local_user = getpass.getuser()

# default timezone
default_timezone = 'America/Toronto'

# days after current date to include
lookahead_day_count = 7

# hour of start of work days (24h clock, in local time)
work_start_hour = 9

# hour of start of work days (24h clock, in local time)
work_end_hour = 17

# Whether or not to include Saturday and Sunday
skip_weekends = True

# show all calendars or only specified ones (see next setting)
show_all_cal = True

# string of calendar IDs in parens (only applies if show_all_cal is False)
# calendar IDs can be identified by running "calendar-avail-listcals.py"
cal_list = '(60)'



# Offset the start and end times for the db query from the calendar epoch and convert to seconds

epoch_anchor_utc = datetime.datetime.strptime("01-01-2001", "%m-%d-%Y")
query_start_utc = datetime.datetime.utcnow()
query_end_utc = query_start_utc + datetime.timedelta(
    seconds=lookahead_day_count * 24 * 60 * 60)

query_start_seconds = abs((query_start_utc - epoch_anchor_utc).days) * 24 * 60 * 60
query_end_seconds = abs((query_end_utc - epoch_anchor_utc).days) * 24 * 60 * 60

# Connect to Calendar sqlite DB and query events

conn = sqlite3.connect("/Users/%s/Library/Calendars/Calendar Cache" % local_user)
cursor = conn.cursor()

if show_all_cal is True:
    cursor.execute('''select
    	ZSTARTDATE,
    	ZENDDATE,
    	ZTIMEZONE,
    	ZTITLE
        from ZCALENDARITEM
        where ZSTARTDATE &gt; %s
        and ZENDDATE &lt; %s''' % (query_start_seconds, query_end_seconds))
else:
    cursor.execute('''select
    	ZSTARTDATE,
    	ZENDDATE,
    	ZTIMEZONE,
    	ZTITLE
        from ZCALENDARITEM
        where ZSTARTDATE &gt; %s
        and ZENDDATE &lt; %s
        and ZCALENDAR in %s''' % (query_start_seconds, query_end_seconds, cal_list))

calendar_entries = cursor.fetchall()

conn.close()

# convert times from db into datetime objects and sort by start times

calendar_entries_processed = []

for entry in calendar_entries:

    zstartdate = entry[0]
    zenddate = entry[1]
    entry_tz = entry[2]
    title = entry[3]

    try:
        local_tz = pytz.timezone (entry_tz)
    except:
        local_tz = pytz.timezone (default_timezone)

    utc_start = epoch_anchor_utc + datetime.timedelta(seconds=zstartdate)
    utc_start = utc_start.replace(second=0, microsecond=0).replace(tzinfo=pytz.utc)
    utc_end = epoch_anchor_utc + datetime.timedelta(seconds=zenddate)
    utc_end = utc_end.replace(second=0, microsecond=0).replace(tzinfo=pytz.utc)

    calendar_entries_processed.append((utc_start, utc_end, title, entry_tz))

calendar_entries_sorted = sorted(calendar_entries_processed, key=lambda x: x[0])

# Remove all-day events (anything over 23 hours)

for entry in calendar_entries_sorted:
    event_start = entry[0]
    event_end = entry[1]
    if event_end - event_start &gt; datetime.timedelta(hours=23):
        calendar_entries_sorted.remove(entry)

# Build list of the days within the lookahead period, set initial date to today

lookahead_days = []
lookahead_date_utc = datetime.datetime.today().replace(
    hour=0, minute=0, second=0, microsecond=0).replace(tzinfo=pytz.utc)

for x in range(0,lookahead_day_count + 1):
    lookahead_days.append(lookahead_date_utc)
    lookahead_date_utc = lookahead_date_utc + datetime.timedelta(days=1)

# For every date in the lookahead, store all events in the sched_text string

sched_text = ''

for d in lookahead_days:

    wd = calendar.day_name[d.weekday()]
    if skip_weekends == True and (wd == 'Saturday' or wd == 'Sunday'):
            continue

    sched_text += '\n'
    sched_text += wd + ' - ' + str(d)[:10] + '\n\n'
    entry_count = 0
    for entry in calendar_entries_sorted:
        if entry[0] &gt; d and entry[1] &lt; d + datetime.timedelta(days=1):
            entry_count += 1
            start_local = entry[0].astimezone(pytz.timezone (entry[3]))
            end_local = entry[1].astimezone(pytz.timezone (entry[3]))
            sched_text += str(start_local)[11:16] + ' - ' + \
                str(end_local)[11:16] + ' - ' + entry[2] + '\n'
    if entry_count == 0:
        sched_text += '(No Events)' + '\n'

#  Work out busy/free times and store summary in the basummary_text string

basummary_text = ''

for d in lookahead_days:

    busy_minutes = set()
    day_minutes = set()
    busy_avail = []
    utc = pytz.timezone('UTC')

    wd = calendar.day_name[d.weekday()]

    if skip_weekends == True and (wd == 'Saturday' or wd == 'Sunday'):
            continue

    # Check if each entry in the overall list of events occured on this date

    for entry in calendar_entries_sorted:

        entry_start = entry[0]
        entry_end = entry[1]

        if entry_start &gt; d and entry_end &lt; d + datetime.timedelta(days=1):

            # Found an event that occurs today

            entry_num_minutes = abs((entry_end - entry_start).seconds) / 60

            # add start minute for the event to the busy_minutes set
            busy_minutes.add(entry_start)

            # add all other minutes that fall within event to the busy_minutes set
            for x in range(1, entry_num_minutes):
                busy_minutes.add(entry_start + datetime.timedelta(minutes=x))

    day_start_local = d.astimezone(pytz.timezone (default_timezone)).replace(
        hour=work_start_hour, minute=0, second=0, microsecond=0)

    if d.day != day_start_local.day:
        day_start_local = day_start_local + datetime.timedelta(days=1)

    day_end_local = d.astimezone(pytz.timezone (default_timezone)).replace(
        hour=work_end_hour, minute=0, second=0, microsecond=0)

    if d.day != day_end_local.day:
        day_end_local = day_end_local + datetime.timedelta(days=1)

    day_start = day_start_local.astimezone(utc)
    day_end = day_end_local.astimezone(utc)

    day_num_minutes = abs((day_end - day_start).seconds) / 60

    day_minutes.add(day_start)

    for x in range (1, day_num_minutes):
        m = day_start + datetime.timedelta(minutes=x)
        m_utc = m.astimezone(utc)
        day_minutes.add(m_utc)

    busy_minutes_filtered = set()

    for m in busy_minutes:
        if m &lt; day_end and m &gt; day_start:
            busy_minutes_filtered.add(m)

    avail_minutes = day_minutes.symmetric_difference(busy_minutes_filtered)

    for x in avail_minutes:
        busy_avail.append((x, 'Available'))

    for x in busy_minutes_filtered:
        busy_avail.append((x, 'Busy'))

    busy_avail_sorted = sorted(busy_avail, key=lambda x: x[0])

    # Busy/Avail summary

    basummary_text += '\n'
    basummary_text += wd + ' - ' + str(d)[:10] + '\n\n'

    first_minute = busy_avail_sorted[0][0]
    first_status = busy_avail_sorted[0][1]

    start_of_streak_time = first_minute
    temp_end_time = first_minute + datetime.timedelta(seconds=60)
    temp_last_status = first_status


    for entry in busy_avail_sorted[1:]:
        entry_time = entry[0]
        entry_status = entry[1]

        if entry != busy_avail_sorted[-1]:

            if entry_status == temp_last_status:
                # streak ongoing
                temp_end_time = entry_time + datetime.timedelta(seconds=60)
            else:
                # streak broken
                basummary_text += str(start_of_streak_time.astimezone(
                    pytz.timezone (default_timezone)))[11:16] + ' to ' + str(
                        temp_end_time.astimezone(pytz.timezone (
                                default_timezone)))[11:16] + ' - ' + temp_last_status
                basummary_text += '\n'
                temp_last_status = entry_status
                start_of_streak_time = entry_time

        # last item in list
        else:
            temp_end_time = temp_end_time + datetime.timedelta(seconds=60)
            basummary_text += str(
                start_of_streak_time.astimezone(pytz.timezone (
                    default_timezone)))[11:16] + ' to ' + str(
                        temp_end_time.astimezone(pytz.timezone (
                            default_timezone)))[11:16] + ' - ' + temp_last_status
            basummary_text += '\n'

# comment out one of the two lines below depending on whether the schedule
# summary or busy/available summary shoudl be copied to the clipboard

# write_to_clipboard(basummary_text)
write_to_clipboard(sched_text)
</string>
				<key>scriptargtype</key>
				<integer>0</integer>
				<key>scriptfile</key>
				<string></string>
				<key>type</key>
				<integer>3</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>B0E2DAEB-48D4-43F5-B2DB-2C9CE2F8B3EE</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>lastpathcomponent</key>
				<false/>
				<key>onlyshowifquerypopulated</key>
				<false/>
				<key>removeextension</key>
				<false/>
				<key>text</key>
				<string></string>
				<key>title</key>
				<string>Schedule copied to clipboard</string>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.notification</string>
			<key>uid</key>
			<string>FFCD5930-BD14-4FEC-A342-F99A6A8C5A56</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
	</array>
	<key>readme</key>
	<string></string>
	<key>uidata</key>
	<dict>
		<key>0896B426-0376-4FDA-B15E-12BA2F091969</key>
		<dict>
			<key>xpos</key>
			<integer>300</integer>
			<key>ypos</key>
			<real>180</real>
		</dict>
		<key>15299C7A-CDEA-4359-8898-446F2892DB7C</key>
		<dict>
			<key>xpos</key>
			<integer>300</integer>
			<key>ypos</key>
			<real>60</real>
		</dict>
		<key>A70A4E1E-712E-4575-967A-0AA64960904D</key>
		<dict>
			<key>xpos</key>
			<integer>700</integer>
			<key>ypos</key>
			<real>60</real>
		</dict>
		<key>B0E2DAEB-48D4-43F5-B2DB-2C9CE2F8B3EE</key>
		<dict>
			<key>xpos</key>
			<integer>500</integer>
			<key>ypos</key>
			<real>180</real>
		</dict>
		<key>FF316160-82F1-4AC1-8D82-72A1F0AC9ED6</key>
		<dict>
			<key>xpos</key>
			<integer>500</integer>
			<key>ypos</key>
			<real>60</real>
		</dict>
		<key>FFCD5930-BD14-4FEC-A342-F99A6A8C5A56</key>
		<dict>
			<key>xpos</key>
			<integer>700</integer>
			<key>ypos</key>
			<real>180</real>
		</dict>
	</dict>
	<key>webaddress</key>
	<string>https://github.com/kmarchand/calendar-avail</string>
</dict>
</plist>
